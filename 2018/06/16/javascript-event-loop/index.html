<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Promise 与 JavaScript 的事件循环 | 脑袋的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Promise 与 JavaScript 的事件循环</h1><a id="logo" href="/.">脑袋的博客</a><p class="description">BrainBag's Blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Promise 与 JavaScript 的事件循环</h1><div class="post-meta">Jun 16, 2018<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么要有事件循环？"><span class="toc-number">1.</span> <span class="toc-text">为什么要有事件循环？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件循环机制"><span class="toc-number">2.</span> <span class="toc-text">事件循环机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-的执行顺序"><span class="toc-number">3.</span> <span class="toc-text">Promise 的执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回到最初的练习题"><span class="toc-number">4.</span> <span class="toc-text">回到最初的练习题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章"><span class="toc-number">5.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="post-content"><p>之前去滴滴面试的时候面试官问：「有用到什么新的技术么？」，正好最近学 Promise 就恬不知耻地说了，没想到面试官突然在电脑上啪啪啪敲了一阵后把电脑一翻：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码是从记忆里扒出来的，可能与原题有出入</span></span><br><span class="line"><span class="comment">// 大概看个意思</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br></pre></td></tr></table></figure>
<p>「写一下这段代码的输出吧。」</p>
<p>当时我就懵逼了，前阵子确实看到过 Promise 的事件循环，但是我为什么扫！一！眼！就！关！掉！了！网！页！</p>
<p>好吧，面试挂了就挂了，回来赶紧补补课——</p>
<p>PS: 文章内容是自己结合网上各个博客对 JavaScript 事件循环的理解，肯定会有或大或小的错误，如果你和我一样是菜鸡，请辩证地看待，不要全信！如果你是大牛，欢迎欢迎！敬请指正！让批评来得更猛烈些吧！</p>
<p>PPS: 以我的写作风格估计下面肯定又是长长一大坨，所以先在这里送上上面这道题的答案吧： <code>2 5 4 1 3</code> （根据 Promise 实现不同答案可能有出入，此处以 Promise 注册微任务（micro-task）的形式给出答案，当然，如果现在看不懂的话，那就接着看吧！）。</p>
<h1 id="为什么要有事件循环？"><a href="#为什么要有事件循环？" class="headerlink" title="为什么要有事件循环？"></a>为什么要有事件循环？</h1><p>虽然用了一道面试题做开篇，但实际上这篇文章想要梳理的是事件循环的问题，包括 Promise 和 <code>setTimeout</code> 等函数中的任务执行顺序。</p>
<p>为什么会出现这样的问题呢？这就要牵扯到 JavaScript 是单线程的这一点了，单线程可以避免出现多线程的同步、锁的问题，但是只有一个线程（后文称之为主线程）在执行，一旦出现定时器等场景该怎么办呢？现在有两种解决方案：</p>
<ol>
<li>停下来等计时到了再执行后面的任务。这种方法被称为 <strong>同步</strong>，很明显这种形式非常不好，在这段时间内主线程会一直等待计时任务完成，而这段时间完全可以给主线程安排其它的任务。</li>
</ol>
<blockquote>
<p><strong>不是需要进行计时么，为什么主线程不是执行计时任务，而是处于等待状态？</strong></p>
<p>实际上计时器并非由 JavaScript 执行，我们说的「单线程」只是解析、执行 JavaScript 代码的线程为单线程，而实际中会有许多其它的线程，比如计时器线程、处理网络请求的线程、处理 DOM 事件的线程等等，此处举例的计时器便交付给计时器线程完成，主线程本身不执行计时任务。</p>
</blockquote>
<ol start="2">
<li>先做后面的任务，有空了再确认一下计时任务是不是完成了，有没有需要在计时任务之后做的事情。这种方法被称为 <strong>异步</strong>，也就是无需当场确认结果，而是在之后通过其它的方式得到。一般会将结果作为回调函数的参数传入，主线程在执行回调函数时便「得到」了该结果。</li>
</ol>
<blockquote>
<p><strong> 回调函数就是异步么？</strong></p>
<p>不是，回调函数是指「将函数传入，在当前函数执行时可以调用这个函数」的这个形式，只是异步将其作为了获取任务结果的一种方法，同步也是可以使用回调函数的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'我是个回调函数'</span>);</span><br><span class="line"><span class="keyword">const</span> syncTask = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'同步任务开始'</span>);</span><br><span class="line">    cb();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'同步任务结束'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">syncTask(callback);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这里的 <code>syncTask</code> 便是一个同步任务，它传入了 <code>callback</code> 并在执行期间「回调了」这个函数。</p>
</blockquote>
<p>好，那现在我们决定好了要用异步的方式解决计时任务了，那么什么时候才叫「有空」呢？如果有多个异步任务返回结果了，该用什么方式执行呢？</p>
<p>这就是事件循环机制要做的了。</p>
<h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><p>这里先提一句，事件循环机制并非由 JavaScript 引擎提供，而是 JavaScript 运行环境提供的一种机制，emmmmm，我也只能理解到这里了，再往深就要懂更底层的东西了，比如 V8 引擎，Node 运行时等，我猜是编译原理的内容，希望能有大牛指点一二。下面讲的内容都是在 Node 运行时上的内容，但浏览器中应该也是相似的。</p>
<p>如前文述，事件循环是用来解决多个异步任务回调事件执行顺序的，现在只有一个主线程，但却有可能同时收到 Ajax，计时器，Promise 等多个回调的事件要做，而且在处理其中一些事件的过程中，还可能有事件源源不断地产生，这便需要循环往复地查看是否还有事件需要完成。</p>
<p>为了理解事件循环，我们可以将事件分为两个大类：微任务事件和宏任务事件，它们下面又可以分出一些小类，具体的等一下再说，我们先着眼于事件循环的执行过程。事件循环中维护了两条微任务队列与六条宏任务队列，每条队列会存储对应的不同类的事件，主线程便按照一定顺序去循环往复地执行这些队列，如图所示：</p>
<p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/Snipaste_2018-06-21_22-39-25.png" alt="事件循环机制"></p>
<p>可以看到在执行完用户代码与微任务队列后便进入了事件循环，依据 Timer → Pending i/o callbacks → Idle, prepare → Poll → Check → Close callbacks 的宏队列顺序进行检查。</p>
<p>每一步宏任务队列的检查都会确认当前队列中是否有需要执行的事件，并将队列中的事件按顺序执行完毕，再以 nextTickQueue → microTaskQueue 的顺序检查两条微任务队列是否有事件并执行完毕。</p>
<p>所以实际上微任务的「优先级」是高于宏任务的，当前宏任务中如果产生了新的微任务事件，则在当前宏任务结束后就会执行，而不需要等到下一轮事件循环。</p>
<blockquote>
<p><strong>具体每个队列里分别对应什么事件呢？</strong></p>
<p>我觉得这个并不影响对事件循环的理解，所以就放在这里吧：</p>
<ul>
<li>微任务<ul>
<li>nextTickQueue: process.nextTick</li>
<li>microTaskQueue: 其它微任务</li>
</ul>
</li>
<li>宏任务<ul>
<li>Timer: setTimeout, setInterval 等</li>
<li>Pending i/o callbacks: 除了 timers, setImmediate 及 close 之外的大多数回调方法</li>
<li>Idle, prepare: 只在内部调用</li>
<li>Poll: 检查是否有新的 I/O 事件</li>
<li>Check: setImmediate</li>
<li>Close: socket.on(‘close’, …) 等</li>
</ul>
</li>
</ul>
<p>更详细的可以参考 <a href="https://juejin.im/post/5b02693d518825426b277da0" target="_blank" rel="noopener">详解“Node.js环境”中的event loop机制 - 掘金</a> 等其它博客，或者直接查看 Node.js 文档。<br>setTimeout 和 setImmediate 的执行情况不能简单按这里给的任务分类推断，有兴趣可以看看 <a href="http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/" target="_blank" rel="noopener">setImmediate() vs nextTick() vs setTimeout(fn,0) – in depth explanation | Void Canvas</a> 这篇文章，另外 <a href="https://juejin.im/post/5a62e142f265da3e2b16810f" target="_blank" rel="noopener">JavaScript运行机制深入浅出学习 - 掘金</a> 这篇文章中也有简要叙述（我就是喜欢看中文的嘿）。</p>
</blockquote>
<h1 id="Promise-的执行顺序"><a href="#Promise-的执行顺序" class="headerlink" title="Promise 的执行顺序"></a>Promise 的执行顺序</h1><p>好了，事件循环知道得差不多了，但为什么微任务和宏任务队列分类里没有 Promise 呢？这就要关系到 Promise 的执行顺序问题。</p>
<p>还是先甩个例子吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. resolve 之前'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. resolve 之后'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. then 之中'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当 Promise 被构造时即会执行其构造函数中传入的函数，也就是说例子中的 <code>fn1</code> 函数本身是在当前线程 <strong>同步</strong> 执行的。那执行 <code>resolve()</code> 时是否就是执行 <code>then</code> 中的函数呢？非也，<code>resolve()</code> 会将当前 Promise 实例设置成 <code>onFulfilled</code> 状态，并将参数记录下来在调用 <code>then</code> 中的函数时执行。</p>
<p>那构建完成了 Promise 实例之后呢，立即执行 <code>then</code> 中的函数么？非也非也，如果这样的话我前面还叽叽喳喳事件循环干什么呢？实际上 <code>then</code> 中的函数会被添加到任务队列中。</p>
<p>那到底是宏队列还是微队列呢？别卖关子啊！</p>
<p>好吧，其实不是我卖关子，是 Promise 规范中并未规定啊：</p>
<blockquote>
<p><strong><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+ 规范</a>（<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">中文翻译</a>）</strong></p>
<p>In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick.</p>
<p>实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。</p>
</blockquote>
<p>所以 Promise 的结果还是要看 JavaScript 执行环境的实现了，这一小节的例子因为只有一个事件，所以结果并不会因为宏任务或微任务而改变，都是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> resolve 之前</span><br><span class="line"><span class="number">2.</span> resolve 之后</span><br><span class="line"><span class="number">3.</span> then 之中</span><br></pre></td></tr></table></figure>
<p>小结一下 Promise 的执行便是：</p>
<ul>
<li>构造函数内传入的函数会在主线程执行时同步执行，遇到 <code>resolve/reject</code> 函数（函数名只是示例，实际上是传入函数的前两个参数）时更改 Promise 状态；</li>
<li>根据执行环境将 Promise 的 <code>then/catch</code> 内的函数加入相应任务队列，由事件循环机制管理。</li>
</ul>
<h1 id="回到最初的练习题"><a href="#回到最初的练习题" class="headerlink" title="回到最初的练习题"></a>回到最初的练习题</h1><p>现在可以来回顾一下最初的题目了，我知道翻回去很累，就在这再贴一次 <del>占字数</del>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br></pre></td></tr></table></figure>
<p>如果 Promise 的 <code>then</code> 方法将事件注册进微任务队列的话，执行顺序如下：</p>
<ol>
<li><code>setTimeout</code> 的回调放入宏任务队列，Promise 实例构造过程中输出 <code>2</code>，当 <code>i==99</code> 时设置该 Promise 为 onFulfilled 状态，把 <code>then</code> 里的回调放入微任务队列，Promise 中的 <code>setTimeout</code> 回调也放入宏任务队列，最后输出 <code>5</code>；</li>
<li>检查微任务队列，输出 <code>4</code>；</li>
<li>检查宏任务队列，依序输出 <code>1</code>、<code>3</code>。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html​" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop - 阮一峰</a></li>
<li><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">【朴灵评注】JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></li>
</ul>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2019/03/31/download-pdf-from-cnki/">从知网（CNKI）下载 PDF 版文献</a><a class="next" href="/2018/05/10/first-step-of-blog/">惯例的第一篇：搭建博客，从申请域名到撰写博文</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: '1529156494000',
  owner: 'oopp1800',
  repo: 'oopp1800.github.io',
  oauth: {
    client_id: 'd0c3824b30919466887a',
    client_secret: 'ecf87270d6bc9c1d61efe585eaaf2bd2fdcdce06',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://blog.bbag.me"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件技巧/">软件技巧</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/博客-域名-HTTPS-Hexo/" style="font-size: 15px;">博客 域名 HTTPS Hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/31/download-pdf-from-cnki/">从知网（CNKI）下载 PDF 版文献</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/javascript-event-loop/">Promise 与 JavaScript 的事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/first-step-of-blog/">惯例的第一篇：搭建博客，从申请域名到撰写博文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://jcf94.com/" title="Chenfan Blog" target="_blank">Chenfan Blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">脑袋的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>