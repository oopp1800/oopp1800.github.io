<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>脑袋的博客</title>
  
  <subtitle>BrainBag&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.bbag.me/"/>
  <updated>2019-04-08T02:43:48.748Z</updated>
  <id>https://blog.bbag.me/</id>
  
  <author>
    <name>Brain Bag</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从知网（CNKI）下载 PDF 版文献</title>
    <link href="https://blog.bbag.me/2019/03/31/download-pdf-from-cnki/"/>
    <id>https://blog.bbag.me/2019/03/31/download-pdf-from-cnki/</id>
    <published>2019-03-31T12:49:37.000Z</published>
    <updated>2019-04-08T02:43:48.748Z</updated>
    
    <content type="html"><![CDATA[<p>从知网下载过文献，特别是学位论文的小伙伴们肯定知道 CAJ 这个格式了。作为知网的专有格式，它的好处好像只是让知网能够把我们圈在它的 CAJ 云阅读软件里。但就算抛开这个软件的难用程度不提（其实我很少用啦，可能有人觉得好用，那就不是这篇文章的目标读者啦），PDF 作为一个更加通用的格式，在存储、分享等多个方面都远好于 CAJ（单单是在 Windows 里能显示缩略图就不知道比 CAJ 高到哪里去了）。</p><p>所以嘞，借此整理整理手头上能够从知网获得 PDF 文献的方法，顺便做一个分享，同时感谢各个方法的创始及维护人员，如果有动手能力强的同学可以直接看下面的简洁版——</p><h1 id="简洁版"><a href="#简洁版" class="headerlink" title="简洁版"></a>简洁版</h1><p>从知网获取 PDF 文献，除了知网直接提供 PDF 下载地址的文献外，目前我搜集到的还有几种获取方法：</p><ol><li>通过脚本获取知网下载 PDF 的接口</li></ol><p>建议适用：期刊/会议论文、对 PDF 目录无要求者</p><p>关键词：TamperMonkey/油猴，CNKI PDF Download</p><p>但这种方式下载到的 <strong>学位论文大多没有目录</strong>，所以下载学位论文建议使用第二种方法。</p><ol start="2"><li>下载 CAJ 版本论文，转换为 PDF</li></ol><p>建议适用：学位论文</p><p>关键词：CAJ2PDF</p><p>这种方式不是 100% 成功的，部分 CAJ 无法转换，如果不行的话建议使用第一种方式，配合挂载 PDF 目录的方法使用（将在下文详述）。</p><ol start="3"><li>下载 CAJ 版本论文，打印为 PDF 版</li></ol><p>建议适用：上述方法皆失效，且一定需要 PDF 版本</p><p>关键词：CAJ 云阅读，虚拟打印</p><p>这种方式打印出来的是 <strong>纯图片 PDF</strong>，无法选中文字等，属于实在没有办法后的下下之选。</p><h1 id="方法1-脚本获取-CNKI-隐藏-PDF-下载入口"><a href="#方法1-脚本获取-CNKI-隐藏-PDF-下载入口" class="headerlink" title="方法1: 脚本获取 CNKI 隐藏 PDF 下载入口"></a>方法1: 脚本获取 CNKI 隐藏 PDF 下载入口</h1><blockquote><p>给脚本贡献者 <a href="https://greasyfork.org/zh-CN/users/39034-yue" target="_blank" rel="noopener">yue</a> 和 <a href="https://greasyfork.org/zh-CN/scripts/368399-cnki-pdf-download" target="_blank" rel="noopener">Arnie97</a> 点赞</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>调用海外版的知网 PDF 下载接口 (<a href="http://new.oversea.cnki.net/index/" target="_blank" rel="noopener">http://new.oversea.cnki.net/index/</a>) 进行下载</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN" target="_blank" rel="noopener">TamperMonkey</a></li><li><a href="https://greasyfork.org/scripts/368399" target="_blank" rel="noopener">CNKI PDF Download 脚本</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>安装好 TamperMonkey 和 CNKI PDF Download 脚本（可能需要科学上网）（Chrome 里是使用 TamperMonkey，其它平台我也没用过，只能自行查找相应插件了……）</li><li>打开知网论文页面，就会发现多了一个按钮——</li></ol><p><img src="pdf-download-button.png" alt="Duang~地一声就多了一个按钮"></p><ol start="3"><li>还需要说么？点击下载吧！</li></ol><p>但是这种方式下下来的论文大多是没有目录的，一方面强迫症受不了，另一方面有时候确实需要目录了解大致结构，前后跳转观看，所以只能再另行寻找方法了——</p><h2 id="Bonus-——-为-PDF-挂载目录"><a href="#Bonus-——-为-PDF-挂载目录" class="headerlink" title="Bonus —— 为 PDF 挂载目录"></a>Bonus —— 为 PDF 挂载目录</h2><p>既然没有目录，那就强行为它挂上目录吧！不过下面介绍的方法目录精度是以「页」为单位的，如果需要更高精度的，建议优先查看方法 2.</p><blockquote><p>特别感谢本方法的提供者：<a href="http://blog.sina.com.cn/s/blog_d1ebd8ae0102wejz.html" target="_blank" rel="noopener">jay_东风破</a>、<a href="http://blog.sina.com.cn/u/1993699760" target="_blank" rel="noopener">旺达与阿格罗</a></p></blockquote><p>用到的工具是 <a href="https://pan.baidu.com/s/16XomLj0aK3P3iUleNlKajA" target="_blank" rel="noopener">FreePic2PDF</a>，下好之后打开并点击右下角的「更改PDF」，能看到如下界面：</p><p><img src="操作步骤图1.png" alt="操作步骤图1"></p><p>按照图上顺序点击「从PDF取书签」①，打开对应 PDF 文件 ②，点击「开始」③，就能够获取到一个书签目录，再切换到「往PDF挂书签」Tab ④，点击书签目录图标 ⑤ 即可看到如下界面，当然这时候是书签内容应该是空的，或者只有一个「?」。</p><p><img src="操作步骤图2.png" alt="操作步骤图2"></p><p>那我们从哪里找书签呢——知网已经给我们预备好了。我们回到 PDF 的下载页面，点击分章下载按钮：</p><p><img src="分章下载.png" alt="分章下载按钮"></p><p>Ctrl+A 全选页面内容，复制——目录到手了！然后再去刚刚的软件页面把目录粘贴进去。同样 Ctrl+A 全选目录，点击自动缩进按钮 ⑦，保存书签目录 ⑧，关闭当前软件页面，回到一开始挂书签的地方，点击「开始」⑨，完成！</p><p>这时候打开 PDF，是不是已经有书签了！同时目录下还会有一个同名的目录，里面保存的是刚刚提取出来的书签目录，修改完毕后我们已经把该目录挂载到 PDF 里了，所以这个文件夹就可以删掉了~</p><p>刚才编辑书签的界面还有许多高级编辑的内容，有需求的话可以自己再探索探索~</p><p>总结一下方法就是——提取书签，挂载书签，格式化书签，保存书签，是不是 so~easy~</p><h1 id="方法2-CAJ-转换为-PDF"><a href="#方法2-CAJ-转换为-PDF" class="headerlink" title="方法2: CAJ 转换为 PDF"></a>方法2: CAJ 转换为 PDF</h1><p>如果手头上已经有 CAJ 文件了，或者觉得上面挂书签的办法太麻烦/精度不够的话，就可以试试直接转换 CAJ 的方法了！</p><blockquote><p>在这里非常非常感谢 <a href="https://github.com/JeziL" target="_blank" rel="noopener">JeziL</a> 提供的 <a href="https://github.com/JeziL/caj2pdf" target="_blank" rel="noopener">caj2pdf</a> 项目，无论是逆向分析还是实现转换的代码并开源给大家使用都让人各种膜拜！</p><p>并且在<a href="https://github.com/JeziL/caj2pdf/wiki" target="_blank" rel="noopener">项目 Wiki</a> 中提供了大神对 CAJ 格式的分析，有志于分析所有 CAJ 格式的大牛们可以去项目中继续讨论贡献！</p></blockquote><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>逆向分析 CAJ 格式并转换为 PDF，具体分析请见 <a href="https://github.com/JeziL/caj2pdf/wiki" target="_blank" rel="noopener">caj2pdf 项目 Wiki</a>。</p><h2 id="环境-工具"><a href="#环境-工具" class="headerlink" title="环境/工具"></a>环境/工具</h2><ul><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 3.3+</a></li><li><a href="https://github.com/JeziL/caj2pdf" target="_blank" rel="noopener">caj2pdf</a></li></ul><p>右上角「Clone or download」点击「Download ZIP」，下载后解压即可</p><ul><li><p><a href="https://github.com/mstamy2/PyPDF2" target="_blank" rel="noopener">PyPDF2</a></p><pre><code>pip install -U PyPDF2</code></pre></li><li><p><a href="https://mupdf.com/downloads/index.html" target="_blank" rel="noopener">mutool</a></p></li></ul><p>下载「mupdf-x.xx.x-windows.zip」，解压后把里面的「mutool.exe」拿出来放在 caj2pdf 的解压目录里即可</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>其实会用命令行的同学直接看项目里写的用法就可以了——</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印文件基本信息（文件类型、页面数、大纲项目数）</span></span><br><span class="line">caj2pdf <span class="keyword">show</span> [input_file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换文件</span></span><br><span class="line">caj2pdf <span class="keyword">convert</span> [input_file] -o/<span class="comment">--output [output_file]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 CAJ 文件中提取大纲信息并添加至 PDF 文件</span></span><br><span class="line"><span class="comment">## 遇到不支持的文件类型或 Bug 时，可用 CAJViewer 打印 PDF 文件，并用这条命令为其添加大纲</span></span><br><span class="line">caj2pdf outlines [input_file] -o/<span class="comment">--output [pdf_file]</span></span><br></pre></td></tr></table></figure><p>这里再稍微详细说明一下：</p><ol><li>把要转换的 CAJ 文件放在 caj2pdf 目录下</li><li>在 caj2pdf 目录空白处按住 shift 键同时右击，选「在此处打开 PowerShell 窗口」</li><li>输入命令：<code>py -3 caj2pdf convert [要转换的 CAJ 名称] -o [转换成的 PDF 名称.pdf]</code>，这里举一个例子：<code>py -3 caj2pdf convert input.caj -o output.pdf</code></li><li>回车！</li><li>如果转换成功的话目录下就会有对应的 PDF 文件了，当然如果提示失败的话…建议看看其它方法哦</li></ol><p>这种方法生产出来的 PDF 个人认为是最完美的，除了——偶尔会失败以外。希望有更多的大牛能参与到这个项目中来~</p><h1 id="方法3-CAJ-虚拟打印成-PDF"><a href="#方法3-CAJ-虚拟打印成-PDF" class="headerlink" title="方法3: CAJ 虚拟打印成 PDF"></a>方法3: CAJ 虚拟打印成 PDF</h1><p>最后的最后，实在实在没有办法了，海外版知网都下不到 PDF，caj2pdf 也转换失败了，emmmmmmmm，如果没有特殊要求的话，其实知网的 CAJ Viewer/CAJ 云阅读 也不是不能用啦。</p><p>当然，这里提供最后的办法——如果你特别特别特别想要 PDF 的话。不过这种方法得到的是每个页面的图片，所以无法选择文字哦，当然相应的高亮啊下划线这种标注也不能用了。如果你还是特别特别特别想要知道的话——那就往下看吧。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>把 CAJ 文件虚拟打印成 PDF 格式，每页都会以图片形式“打印”。</p><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="http://cajviewer.cnki.net/download.html" target="_blank" rel="noopener">CAJ Viewer/CAJ 云阅读</a></li></ul><p>是的，我们还是要用回到知网自己的工具了。这里我用的是 CAJ 云阅读来做演示。</p><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ol><li>打开 CAJ，并点击打印按钮。在 CAJ 云阅读里，打印按钮在左上角非常显眼——</li></ol><p><img src="caj云阅读打印按钮.png" alt="非常显眼的打印按钮"></p><ol start="2"><li>在跳出的窗口里选择虚拟打印机，一般 Windows 默认会有一个叫「Microsoft Print to PDF」，选它就可以了</li></ol><p><img src="caj云阅读打印界面.png" alt="选择虚拟打印机"></p><ol start="3"><li>调整调整格式（其实默认就可以了），点击「确定」打印！</li></ol><p>是不是非常简单粗暴了，但这种方法本身就需要 CAJ 云阅读软件，所以如果不是一定要分享的话，其实不如直接看 CAJ 了，毕竟还能标注、看看大纲啥的不是。</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>我不是方法的生产者，我只是方法的搬运工😂</p><p>前面给一圈脚本/方法贡献者点过赞了，最后还是要点赞下知网君，毕竟一切都是建立在我们能搜索到文献的基础上的~</p><p>也希望看到这篇文章的同学们学业有成，科研顺利（拱手</p><h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><p>2019/04/05 完成第一版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从知网下载过文献，特别是学位论文的小伙伴们肯定知道 CAJ 这个格式了。作为知网的专有格式，它的好处好像只是让知网能够把我们圈在它的 CAJ 云阅读软件里。但就算抛开这个软件的难用程度不提（其实我很少用啦，可能有人觉得好用，那就不是这篇文章的目标读者啦），PDF 作为一个更
      
    
    </summary>
    
      <category term="软件技巧" scheme="https://blog.bbag.me/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise 与 JavaScript 的事件循环</title>
    <link href="https://blog.bbag.me/2018/06/16/javascript-event-loop/"/>
    <id>https://blog.bbag.me/2018/06/16/javascript-event-loop/</id>
    <published>2018-06-16T13:41:34.000Z</published>
    <updated>2019-04-05T07:34:03.028Z</updated>
    
    <content type="html"><![CDATA[<p>之前去滴滴面试的时候面试官问：「有用到什么新的技术么？」，正好最近学 Promise 就恬不知耻地说了，没想到面试官突然在电脑上啪啪啪敲了一阵后把电脑一翻：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码是从记忆里扒出来的，可能与原题有出入</span></span><br><span class="line"><span class="comment">// 大概看个意思</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br></pre></td></tr></table></figure><p>「写一下这段代码的输出吧。」</p><p>当时我就懵逼了，前阵子确实看到过 Promise 的事件循环，但是我为什么扫！一！眼！就！关！掉！了！网！页！</p><p>好吧，面试挂了就挂了，回来赶紧补补课——</p><p>PS: 文章内容是自己结合网上各个博客对 JavaScript 事件循环的理解，肯定会有或大或小的错误，如果你和我一样是菜鸡，请辩证地看待，不要全信！如果你是大牛，欢迎欢迎！敬请指正！让批评来得更猛烈些吧！</p><p>PPS: 以我的写作风格估计下面肯定又是长长一大坨，所以先在这里送上上面这道题的答案吧： <code>2 5 4 1 3</code> （根据 Promise 实现不同答案可能有出入，此处以 Promise 注册微任务（micro-task）的形式给出答案，当然，如果现在看不懂的话，那就接着看吧！）。</p><h1 id="为什么要有事件循环？"><a href="#为什么要有事件循环？" class="headerlink" title="为什么要有事件循环？"></a>为什么要有事件循环？</h1><p>虽然用了一道面试题做开篇，但实际上这篇文章想要梳理的是事件循环的问题，包括 Promise 和 <code>setTimeout</code> 等函数中的任务执行顺序。</p><p>为什么会出现这样的问题呢？这就要牵扯到 JavaScript 是单线程的这一点了，单线程可以避免出现多线程的同步、锁的问题，但是只有一个线程（后文称之为主线程）在执行，一旦出现定时器等场景该怎么办呢？现在有两种解决方案：</p><ol><li>停下来等计时到了再执行后面的任务。这种方法被称为 <strong>同步</strong>，很明显这种形式非常不好，在这段时间内主线程会一直等待计时任务完成，而这段时间完全可以给主线程安排其它的任务。</li></ol><blockquote><p><strong>不是需要进行计时么，为什么主线程不是执行计时任务，而是处于等待状态？</strong></p><p>实际上计时器并非由 JavaScript 执行，我们说的「单线程」只是解析、执行 JavaScript 代码的线程为单线程，而实际中会有许多其它的线程，比如计时器线程、处理网络请求的线程、处理 DOM 事件的线程等等，此处举例的计时器便交付给计时器线程完成，主线程本身不执行计时任务。</p></blockquote><ol start="2"><li>先做后面的任务，有空了再确认一下计时任务是不是完成了，有没有需要在计时任务之后做的事情。这种方法被称为 <strong>异步</strong>，也就是无需当场确认结果，而是在之后通过其它的方式得到。一般会将结果作为回调函数的参数传入，主线程在执行回调函数时便「得到」了该结果。</li></ol><blockquote><p><strong> 回调函数就是异步么？</strong></p><p>不是，回调函数是指「将函数传入，在当前函数执行时可以调用这个函数」的这个形式，只是异步将其作为了获取任务结果的一种方法，同步也是可以使用回调函数的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'我是个回调函数'</span>);</span><br><span class="line"><span class="keyword">const</span> syncTask = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'同步任务开始'</span>);</span><br><span class="line">    cb();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'同步任务结束'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">syncTask(callback);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这里的 <code>syncTask</code> 便是一个同步任务，它传入了 <code>callback</code> 并在执行期间「回调了」这个函数。</p></blockquote><p>好，那现在我们决定好了要用异步的方式解决计时任务了，那么什么时候才叫「有空」呢？如果有多个异步任务返回结果了，该用什么方式执行呢？</p><p>这就是事件循环机制要做的了。</p><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><p>这里先提一句，事件循环机制并非由 JavaScript 引擎提供，而是 JavaScript 运行环境提供的一种机制，emmmmm，我也只能理解到这里了，再往深就要懂更底层的东西了，比如 V8 引擎，Node 运行时等，我猜是编译原理的内容，希望能有大牛指点一二。下面讲的内容都是在 Node 运行时上的内容，但浏览器中应该也是相似的。</p><p>如前文述，事件循环是用来解决多个异步任务回调事件执行顺序的，现在只有一个主线程，但却有可能同时收到 Ajax，计时器，Promise 等多个回调的事件要做，而且在处理其中一些事件的过程中，还可能有事件源源不断地产生，这便需要循环往复地查看是否还有事件需要完成。</p><p>为了理解事件循环，我们可以将事件分为两个大类：微任务事件和宏任务事件，它们下面又可以分出一些小类，具体的等一下再说，我们先着眼于事件循环的执行过程。事件循环中维护了两条微任务队列与六条宏任务队列，每条队列会存储对应的不同类的事件，主线程便按照一定顺序去循环往复地执行这些队列，如图所示：</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/Snipaste_2018-06-21_22-39-25.png" alt="事件循环机制"></p><p>可以看到在执行完用户代码与微任务队列后便进入了事件循环，依据 Timer → Pending i/o callbacks → Idle, prepare → Poll → Check → Close callbacks 的宏队列顺序进行检查。</p><p>每一步宏任务队列的检查都会确认当前队列中是否有需要执行的事件，并将队列中的事件按顺序执行完毕，再以 nextTickQueue → microTaskQueue 的顺序检查两条微任务队列是否有事件并执行完毕。</p><p>所以实际上微任务的「优先级」是高于宏任务的，当前宏任务中如果产生了新的微任务事件，则在当前宏任务结束后就会执行，而不需要等到下一轮事件循环。</p><blockquote><p><strong>具体每个队列里分别对应什么事件呢？</strong></p><p>我觉得这个并不影响对事件循环的理解，所以就放在这里吧：</p><ul><li>微任务<ul><li>nextTickQueue: process.nextTick</li><li>microTaskQueue: 其它微任务</li></ul></li><li>宏任务<ul><li>Timer: setTimeout, setInterval 等</li><li>Pending i/o callbacks: 除了 timers, setImmediate 及 close 之外的大多数回调方法</li><li>Idle, prepare: 只在内部调用</li><li>Poll: 检查是否有新的 I/O 事件</li><li>Check: setImmediate</li><li>Close: socket.on(‘close’, …) 等</li></ul></li></ul><p>更详细的可以参考 <a href="https://juejin.im/post/5b02693d518825426b277da0" target="_blank" rel="noopener">详解“Node.js环境”中的event loop机制 - 掘金</a> 等其它博客，或者直接查看 Node.js 文档。<br>setTimeout 和 setImmediate 的执行情况不能简单按这里给的任务分类推断，有兴趣可以看看 <a href="http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/" target="_blank" rel="noopener">setImmediate() vs nextTick() vs setTimeout(fn,0) – in depth explanation | Void Canvas</a> 这篇文章，另外 <a href="https://juejin.im/post/5a62e142f265da3e2b16810f" target="_blank" rel="noopener">JavaScript运行机制深入浅出学习 - 掘金</a> 这篇文章中也有简要叙述（我就是喜欢看中文的嘿）。</p></blockquote><h1 id="Promise-的执行顺序"><a href="#Promise-的执行顺序" class="headerlink" title="Promise 的执行顺序"></a>Promise 的执行顺序</h1><p>好了，事件循环知道得差不多了，但为什么微任务和宏任务队列分类里没有 Promise 呢？这就要关系到 Promise 的执行顺序问题。</p><p>还是先甩个例子吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. resolve 之前'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. resolve 之后'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. then 之中'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 Promise 被构造时即会执行其构造函数中传入的函数，也就是说例子中的 <code>fn1</code> 函数本身是在当前线程 <strong>同步</strong> 执行的。那执行 <code>resolve()</code> 时是否就是执行 <code>then</code> 中的函数呢？非也，<code>resolve()</code> 会将当前 Promise 实例设置成 <code>onFulfilled</code> 状态，并将参数记录下来在调用 <code>then</code> 中的函数时执行。</p><p>那构建完成了 Promise 实例之后呢，立即执行 <code>then</code> 中的函数么？非也非也，如果这样的话我前面还叽叽喳喳事件循环干什么呢？实际上 <code>then</code> 中的函数会被添加到任务队列中。</p><p>那到底是宏队列还是微队列呢？别卖关子啊！</p><p>好吧，其实不是我卖关子，是 Promise 规范中并未规定啊：</p><blockquote><p><strong><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+ 规范</a>（<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">中文翻译</a>）</strong></p><p>In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick.</p><p>实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。</p></blockquote><p>所以 Promise 的结果还是要看 JavaScript 执行环境的实现了，这一小节的例子因为只有一个事件，所以结果并不会因为宏任务或微任务而改变，都是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> resolve 之前</span><br><span class="line"><span class="number">2.</span> resolve 之后</span><br><span class="line"><span class="number">3.</span> then 之中</span><br></pre></td></tr></table></figure><p>小结一下 Promise 的执行便是：</p><ul><li>构造函数内传入的函数会在主线程执行时同步执行，遇到 <code>resolve/reject</code> 函数（函数名只是示例，实际上是传入函数的前两个参数）时更改 Promise 状态；</li><li>根据执行环境将 Promise 的 <code>then/catch</code> 内的函数加入相应任务队列，由事件循环机制管理。</li></ul><h1 id="回到最初的练习题"><a href="#回到最初的练习题" class="headerlink" title="回到最初的练习题"></a>回到最初的练习题</h1><p>现在可以来回顾一下最初的题目了，我知道翻回去很累，就在这再贴一次 <del>占字数</del>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br></pre></td></tr></table></figure><p>如果 Promise 的 <code>then</code> 方法将事件注册进微任务队列的话，执行顺序如下：</p><ol><li><code>setTimeout</code> 的回调放入宏任务队列，Promise 实例构造过程中输出 <code>2</code>，当 <code>i==99</code> 时设置该 Promise 为 onFulfilled 状态，把 <code>then</code> 里的回调放入微任务队列，Promise 中的 <code>setTimeout</code> 回调也放入宏任务队列，最后输出 <code>5</code>；</li><li>检查微任务队列，输出 <code>4</code>；</li><li>检查宏任务队列，依序输出 <code>1</code>、<code>3</code>。</li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html​" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop - 阮一峰</a></li><li><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">【朴灵评注】JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前去滴滴面试的时候面试官问：「有用到什么新的技术么？」，正好最近学 Promise 就恬不知耻地说了，没想到面试官突然在电脑上啪啪啪敲了一阵后把电脑一翻：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.bbag.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.bbag.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>惯例的第一篇：搭建博客，从申请域名到撰写博文</title>
    <link href="https://blog.bbag.me/2018/05/10/first-step-of-blog/"/>
    <id>https://blog.bbag.me/2018/05/10/first-step-of-blog/</id>
    <published>2018-05-10T14:45:12.000Z</published>
    <updated>2019-04-05T07:34:03.015Z</updated>
    
    <content type="html"><![CDATA[<p>眼看着半只脚要踏入前端工程师的坑了，正好去年申请的域名过期了，纠结了一阵还是申请了一个新域名（我的这个手啊，怎么就不听使唤呢</p><p>域名能干嘛？最最最基础的就是搭个博客了，但又不想再花钱搞个服务器，想到之前在同学博客（强势推广一波→<strong><a href="http://jcf94.com" target="_blank" rel="noopener">jcf94.com</a></strong>）上看到的 Hexo 好像不错，那就造起来！</p><p>搭完博客后总得写点啥吧，苦苦思索数日，实在是肚里没货，那就也来一篇搭建博客的过程好了，权当记录，如果您搭建博客的过程中刚好路过这里又有兴趣阅读下去的话真真是非常感谢了！</p><h1 id="建立博客项目"><a href="#建立博客项目" class="headerlink" title="建立博客项目"></a>建立博客项目</h1><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>首先去 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo 官网</a> 瞅一眼怎么安装，嗨呀，这中文看着怎么就那么爽！</p><p>因为我本地就有 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 和 <a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a> 环境了，所以直接走下一步——<br>（没有的同学可以去 Hexo 官网看看教程，或者直接下载安装就行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 脚手架</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm 是 node.js 用的包管理器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这句话意思就是「在全局安装 hexo-cli」程序</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>脚手架可以认为是帮助我们进行生成基础代码的工具。</p></blockquote><p>拿着这个脚手架就可以搭建 Hexo 博客了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用脚手架初始化博客的代码</span></span><br><span class="line">hexo init &lt;博客项目名字&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入到博客项目文件夹</span></span><br><span class="line">cd &lt;博客项目名字&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装相关依赖项</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>等上几分钟……铛！博客就建好了！</p><p>顺手再进 _config.yml 文件进行一些博客设置，官网有 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">详细的说明</a>，照着改就可以了~<br>运行下服务器：</p><figure class="highlight shell"><figcaption><span>博客根目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在本地运行 hexo 的博客服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后浏览器打开 <code>http://localhost:4000</code>——</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513195136.png" alt="初生的博客"></p><p>博客就搭建完成了！好了这篇文章就到……才不！折腾是无极限的！</p><p>这么丑的博客是没有资格当我的博客的（赶紧先给这个主题的作者认个错）！不设置个主题怎么行？</p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>Hexo 官网提供了一个<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题列表</a>，我 <del>在里面逛了半个小时后</del> 选中了一款 <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">Maupassant</a> 主题，根据文档走起：</p><figure class="highlight shell"><figcaption><span>博客根目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把主题下载到 ./themes/maupassant 里</span></span><br><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装主题的一些依赖，不同主题可能有所不同</span></span><br><span class="line">npm install hexo-renderer-pug</span><br><span class="line">npm install hexo-renderer-sass</span><br></pre></td></tr></table></figure><p>然后进 _config.yml 设置下主题：</p><figure class="highlight yaml"><figcaption><span>/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">maupassant</span></span><br></pre></td></tr></table></figure><blockquote><p>安装不同主题所要执行的命令可能不同，具体参照各个主题的官网说明，大体步骤为 1. 下载主题；2. 设置主题。<br>有一款 <a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">Next</a> 主题好像很多人都在用，这里也推荐下~</p></blockquote><p>重新启动下 hexo 服务器，刷新页面，歘（chuā），页面就不一样了！</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513201913.png" alt="安装主题后的博客"></p><p>主题就安装完成了！好了这篇文章就到……才不！折腾是无极限的！</p><p>随手戳戳页面，嗯？怎么<a href="http://localhost:4000/about/" target="_blank" rel="noopener">「关于」</a>和<a href="http://localhost:4000/atom.xml" target="_blank" rel="noopener">「订阅」</a>页面都是空的？</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513202441.png" alt="空白的订阅页"></p><p>不行，得造起来！</p><blockquote><p>其实也可以关掉这两个页面，页面的控制是归主题管的，在 themes/&lt;对应主题文件夹&gt;/_config.yml 中找到 menu 设置就可以增删不用的页面了。<br>当然，各个主题也可能有不同的设置，具体的还是要去主题官网看，或者研究研究 _config 文件。</p></blockquote><h2 id="生成「关于」页和「订阅」页"><a href="#生成「关于」页和「订阅」页" class="headerlink" title="生成「关于」页和「订阅」页"></a>生成「关于」页和「订阅」页</h2><p>可以在 maupassant 的 _config.yml 中看到：</p><figure class="highlight yaml"><figcaption><span>/themes/maupassant/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">page:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">directory:</span> <span class="string">about/</span></span><br></pre></td></tr></table></figure><p>所以，「关于」页面是一个 <code>page</code>，对应目录为 about/，所以可以用生成页面的方式生成它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用 hexo 生成名为 <span class="string">"about"</span> 的 <span class="string">"page"</span> 类型页面</span></span><br><span class="line">hexo new page "about"</span><br></pre></td></tr></table></figure><blockquote><p>好吧，其实我是网上找的方法啦。</p></blockquote><p>执行完后就可以看到 source 文件夹下生成了 about 文件夹，里面有一个 index.md 文件，是用 Markdown 格式编写的，之后在 <a href="#撰写博文">撰写博文</a> 一节还会提到。</p><p>这里先往里面随便填一点东西：</p><figure class="highlight markdown"><figcaption><span>/source/about/index.md</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">个人信息</span><br><span class="line">---</span><br><span class="line">姓名：脑袋</span><br><span class="line">英文名：Brain Bag</span><br></pre></td></tr></table></figure><p>再戳一下「关于」页面——啾！页面已经可以访问啦！</p><p>那么「订阅」页也……并没有好！这两个页面的作用是不一样的，不能按照同样的方式生成。<br>订阅页是用于别人 <a href="https://zh.wikipedia.org/zh/RSS" target="_blank" rel="noopener">RSS 订阅</a> 博客内容用的。虽然我的博客没啥内容吧，但这些花架式一定要先摆好，万一火了呢（不存在的！</p><p>Hexo 已经提供了订阅页的生成工具 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>，还是一样跟着文档来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>然后编辑一下根目录的（不是主题目录） _config.yml 文件：</p><figure class="highlight yaml"><figcaption><span>/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugin:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RSS 订阅 - by hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>重启下 hexo 服务器，再点一下「订阅」，可以看到 RSS 已经生成好了，完美！</p><p>主要页面就生成完毕了！</p><p>但是往上一看，浏览器顶端的页面小图标还是默认的空白——</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513205950.png" alt="空白的favicon"></p><p>这怎么可以，赶紧造起来！</p><h2 id="设置-favicon"><a href="#设置-favicon" class="headerlink" title="设置 favicon"></a>设置 favicon</h2><p>这个图标被称为 favicon，具体的作用和设计规则这里有一篇非常好的文章：<a href="https://www.uisdc.com/design-perfect-favicon-icon" target="_blank" rel="noopener">设计小测试！教你制作完美的Favicon图标(附神器)</a>，文章提到的 <a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">favicon 制作网站</a>先记上，先把图标画出来。作为半个前端做个图标还不是信手拈来，看我掏出 p…pt 随手一画——</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513210754.png" alt="基于 PPT 的 favicon 设计"></p><p>把图标搞出来，在前面提到的网站上上传，就可以得到一整个图标包了~</p><blockquote><p>提供下我从 PPT 里搞出图片的步骤供参考：<br>复制-&gt;粘贴成图片-&gt;复制粘贴出来的图片-&gt;用 Snipaste 贴图到桌面上-&gt;保存成文件</p></blockquote><p>我的博客只要用到里面的 favicon.ico 与 apple-touch-icon.png 就可以了，把它们粘到 source 文件夹下，一刷新——</p><blockquote><p>我写博客测试的时候不知道为什么还是没有…尝试了重启服务器、重新生成、清除浏览器缓存…<br>但是换个浏览器发现已经可以读取了…</p></blockquote><blockquote><p>有些主题的 favicon 路径是写在主题配置文件中的，可能需要设置主题的 _config.yml 文件。</p></blockquote><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180513215000.png" alt="设置完毕的 favicon"></p><p>可以看到，无论是标题栏或是书签栏都可以显示 <del>精美的</del> 图标了！<br>但是博客只搭建在本地有什么意思？当然是要放到公网上 <del>接收凌辱</del> 以供大家观阅啦。</p><h1 id="传到-GitHub-Pages"><a href="#传到-GitHub-Pages" class="headerlink" title="传到 GitHub Pages"></a>传到 GitHub Pages</h1><p>一般的网站需要部署到服务器上才能访问，而 GitHub 提供了方便的 GitHub Pages 服务，静态的网页只需要部署在该服务上就可以访问了。要做的事情很简单，首先有个 GitHub 帐号，然后创建一个 <github username>.github.io 的仓库（repositories）。</github></p><p>然后在博客根目录的 _config.yml 文件中最底部加入：</p><figure class="highlight yml"><figcaption><span><root>/_config.yml</root></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/&lt;GitHub</span> <span class="string">Username&gt;/&lt;GitHub</span> <span class="string">Username&gt;.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这里的 repo 就是博客的地址了，可以在仓库右上角获取到：</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180518203359.png" alt="在 GitHub 仓库获取 URL"></p><p>接下来的部署过程 Hexo 已经设定好了，只需要：</p><figure class="highlight shell"><figcaption><span><root></root></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 部署 hexo 博客</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>等命令行里显示 <code>done</code>，就可以在 <github username>.github.io 访问到博客了！</github></p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180518203808.png" alt="Hexo 部署完成"></p><blockquote><p>可能是我的 git 之前配置过，不需要输入帐号密码，如果遇到此问题可以参照 <a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这篇文章</a> 进行 SSH key 的设置。</p></blockquote><p>这就结束了么？不！还记得我一开头说我买了个域名么？这才是正事啊！部署到自己的域名上才更有 <del>装逼</del> 归属感！</p><h1 id="个人域名"><a href="#个人域名" class="headerlink" title="个人域名"></a>个人域名</h1><h2 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h2><p>虽然我是在申请好域名之后才想起来搞个博客的，但这里还是说一下域名的申请。</p><p>买域名其实和其它购物一样，选商家，选商品，交钱，拿货，走人！那么去哪儿可以买到域名呢？个人是在 namesilo.com 买的，另外还有 name.com，godaddy.com，阿里云等等，各家提供的域名本身是相同的，但是价格、服务等可能各不相同，这就要靠自己筛选了。</p><blockquote><p>我为什么选 namesilo 呢？</p><p>首先，国内的服务商都要备案，太麻烦了，就先排除在外。然后就是看各家的评价了，namesilo 会赠送 WHOIS 隐私保护，价格好像也最便宜（价格不能只看首年的，还要看续费价格，可能会差很多），就它了！<br>我为什么要写这段话呢，因为我有一个 namesilo 的优惠码 <code>bbag</code>，新用户首次购买可以少 1 美元，我可以拿到首笔订单 10% 的返利，emmmmm，利害关系就是这些了，使用与否任君决定~</p></blockquote><blockquote><p>什么是 WHOIS？</p><p>WHOIS是用来查询互联网中域名的IP以及所有者等信息的传输协议。<br>—— <a href="https://zh.wikipedia.org/zh-cn/WHOIS" target="_blank" rel="noopener">维基百科</a><br>总而言之就是网上直接能查到域名的登记信息，包括申请时填的姓名电话等，而 WHOIS 隐私保护就是域名商提供一个假的 WHOIS 替代，这样别人就不能直接查到登记人了。一般的域名商都会提供 WHOIS 隐私保护服务，具体收费情况就要看各家自己的策略了。</p></blockquote><p>具体的购买步骤就不详述了，输入你想购买的关键字后查找想要的域名购买即可，一般见得多的后缀有 com, me, io 等等，要注意的是 cn 是中国的国别域名，是一定要备案哒。</p><p>那在一通忽悠购买域名后该怎么做才能让它和 GitHub Pages 里的博客关联起来呢？</p><h2 id="关联到-GitHub-Pages"><a href="#关联到-GitHub-Pages" class="headerlink" title="关联到 GitHub Pages"></a>关联到 GitHub Pages</h2><p>首先要在域名商处进行 DNS 设置，如果是想设置类似 blog.bbag.me 的二级域名只需设置 CNAME，而类似 bbag.me 的一级域名则需要配置 ALIAS/ANAME/A 记录的一种。</p><blockquote><p>域名解析到底是干什么的呢，这里给一个 <a href="https://help.aliyun.com/document_detail/29716.html" target="_blank" rel="noopener">阿里云的介绍文档</a><br>简单地可以认为 A 记录用于指向 IP 地址，CNAME 用于指向别的域名，MX 记录用于指向邮件服务器。</p></blockquote><p>这里我使用的是二级域名，所以只需要设置 CNAME 记录就可以了——<br>在 source 目录下新建一个 <strong>没有后缀名</strong> 的 CNAME 文件，里面填上申请的域名：</p><figure class="highlight plain"><figcaption><span>/source/CNAME</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.bbag.me</span><br></pre></td></tr></table></figure><blockquote><p>因为我自己是设置的二级域名，所以就没写怎么设置顶级域名了，关于顶级域名的配置可以见 <a href="https://help.github.com/articles/setting-up-an-apex-domain/" target="_blank" rel="noopener">GitHub 的官方说明</a> 或者 <a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这篇知乎专栏</a>。</p></blockquote><p>这是为了部署到 GitHub Pages 后让它知道要指向的域名。<br>然后进行部署：</p><figure class="highlight shell"><figcaption><span><root></root></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候在 GitHub 仓库的 settings 下应该就可以看到 GitHub Pages 设置成功了！</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180519200714.png" alt="GitHub Pages 指向自定义域名"></p><p>但是光 GitHub 知道还不行，还要告诉 DNS 如何解析，如果没有特别指定域名服务器的话就是在域名服务商处进行设置，比如我就是在 namesilo 里设置 CNAME:</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180520224149.png" alt="设置 DNS 解析"></p><blockquote><p>域名解析可能需要一段时间才能生效…</p></blockquote><p>再访问下自己的域名——</p><p>完美~</p><p>不！等等！</p><p>为什么别人家的网站都有小绿锁而我的没有？</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180519201154.png" alt="看起来很安全的小绿锁"></p><p>不行，我也要小绿锁！</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180519201314.png" alt="我全都要"></p><h2 id="设置-HTTPS"><a href="#设置-HTTPS" class="headerlink" title="设置 HTTPS"></a>设置 HTTPS</h2><p>要小绿锁呢当然不是为了好看，是为了安全 <del>和治疗强迫症</del>，自 5 月 1 日起 GitHub Pages 已经支持自定义域名的 HTTPS 设置了，只需要在 GitHub 的 settings 里一点：</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180527193252.png" alt="在 GitHub 中设置强制 HTTPS 访问"></p><blockquote><p>其实之前是使用 CloudFlare 的服务设置的 HTTPS，但之后看了 <a href="https://nickjanetakis.com/blog/lets-encrypt-vs-cloudflare-for-https" target="_blank" rel="noopener">这篇博文</a>，让我决定还是使用 GitHub Pages 提供的服务。<br>这篇文章主要指出了 CloudFlare 服务的几个缺点：</p><ol><li>“Flexible SSL” 模式仅仅在用户与 CloudFlare 之间采用加密连接，而 CloudFlare 与原始服务器间仍采用未加密通信；</li><li>由于是共享的 SSL 证书，所以查看 SSL 证书时会看到许多无关的域名和我的域名关联在一个证书上。</li></ol><p>总而言之，既然 GitHub 提供了更好的 HTTPS 服务又为什么不用呢~</p></blockquote><p>勾选完毕后耐心地等上一段时间（24 小时内）再登上我的博客就可以看到鲜艳的绿锁了！查看一下证书可以看到，GitHub 是与 Let’s Encrypt 合作提供的 SSL 服务：</p><p><img src="https://blog-1251731977.cos.ap-beijing.myqcloud.com/20180527195147.png" alt="小绿锁以及证书信息"></p><p>但是这里有一点需要注意的，小绿锁只有在全站的内容都是通过 HTTPS 访问才会显示，这就要求了站内的图片等也要走 HTTPS。如果要求不高的话可以选用 <a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?hl=zh-CN&amp;utm_source=chrome-ntp-launcher" target="_blank" rel="noopener">微博图床</a>，可以将图片传到新浪微博的服务器。</p><p>但考虑到这种方式可能利用了微博的某些后门，万一哪天微博心情不好一封了之咱博客的图片可就全挂了。博客还是掌握在自己的手里才安心啊，翻了一圈云服务之后，我决定选 <a href="https://cloud.tencent.com/product/cos" target="_blank" rel="noopener">腾讯云 COS</a> 作为我的坚实后盾。为什么？因为免费啊！每个月 10GB 流量足够我可劲造了。什么？不够怎么办？那说明我火了啊！火了还怕什么资费问题~</p><p>这里再推荐一个方便传图的工具：<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">PicGo</a> 就可以通过快捷键一键传图了~<br>Mac 上有个 <a href="https://itunes.apple.com/cn/app/id1101244278?ls=1&amp;mt=12&amp;at=1000lv4R&amp;ct=iPic_home" target="_blank" rel="noopener">iPic</a> 也是同样功能~</p><p>好了，一切准备就绪，终于可以开始写博客了！</p><h1 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h1><p>先生成一篇文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一篇名为 &lt;title&gt; 的文章</span></span><br><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><p>在 <root>/source/_posts 就可以看到新建的文章了，找个文本编辑器打开它——嗯…嗯？这都是些啥呀：</root></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hello-world</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-05</span><span class="bullet">-27</span> <span class="number">20</span><span class="string">:16:07</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>最顶端用 <code>---</code> 分隔出来的部分叫 Front-matter，是用来告诉 hexo 文章的一些属性的，比如 <code>title</code> 代表文章的标题，<code>date</code> 代表文章创建日期等等，具体有哪些可以在 <a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Hexo 文档</a> 内找到。</p><p>在第二个 <code>---</code> 之后就可以泼墨挥毫了，但是，我这篇博客里花花绿绿的格式是什么呢？图片又怎么插入呢？这就需要 Markdown 的支持了。Hexo 支持 <a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">GitHub Flavored Markdown</a> 的所有功能，使用 Markdown 语法写出的文档可以被正确渲染，比如 <code>**强调**</code> 渲染出的效果就是：<strong>强调</strong>。</p><blockquote><p>但我试了一下 GitHub 插入 emoji 的语法好像不可以，比如：:thumbsup:<br>这里的「支持所有功能」是 Hexo 官网说的，我就照着写了。<br>当然也可以通过第三方插件支持 emoji，这里就不展开了。</p></blockquote><p>Markdown 本身就是为文字工作设计的语言，所以不用担心太复杂，只需要照着文档敲一遍基本上就能非常熟练辣。</p><p>写完！生成！发布！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据 <span class="built_in">source</span> 里的博文生成对应的博客网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署到线上（GitHub Pages）</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这回终于完成了吧……连文章都发上去了难道还有什么问题不成？</p><p>等等！</p><p>怎么没有评论！</p><p>不行！我得加上！</p><h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>对我这种菜鸡来说写的文章肯定有许多纰漏，要是没有评论的话别人也不能进行指正，误导了更多的人可不好（不，并没有人访问这个博客的）。</p><p>评论一般是由主题提供的，比如我使用的 Maupassant 便提供了 disqus, 友言, LiveRe, 畅言, Gitment, Gitalk, Valine 等多个评论系统接入方式，大多数系统只需要在 /themes/maupassant/_config.yml 中填入相应信息即可，但我在选用 Gitment 作为评论系统的时候出了点问题，这里记录一下：</p><p>当 Gitment 初始化文章评论时一直失败，查看发送的请求可以看到返回的错误为 <code>Error: validation failed</code>，经过一阵子谷歌后发现，Gitment 是使用 GitHub 的 Issues 存储评论的，并且使用文章地址作为 issue 的 label 进行索引。但是在 GitHub 某版本更新后 label 的长度被限制为 50 字符，所以当文章地址太长时就会出现初始化错误的问题。</p><p>既然知道了问题所在，那解决方案也非常简单：使用一个小于 50 字符且不重复的字符串作为文章的 label 即可。一般使用文章的时间即可——毕竟没有人会在同一秒内创建两篇博客吧。</p><p>具体地，可以找到 /themes/maupassant/comments.pug 进行修改：</p><figure class="highlight js"><figcaption><span>/themes/maupassant/comments.pug</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">        id: <span class="string">'#&#123;page.date&#125;'</span>, <span class="comment">// 修改这一行，使 id 为文章的日期</span></span><br><span class="line">        owner: <span class="string">'#&#123;theme.gitment.owner&#125;'</span>,</span><br><span class="line">        repo: <span class="string">'#&#123;theme.gitment.repo&#125;'</span>,</span><br><span class="line">        oauth: &#123;</span><br><span class="line">          client_id: <span class="string">'#&#123;theme.gitment.client_id&#125;'</span>,</span><br><span class="line">          client_secret: <span class="string">'#&#123;theme.gitment.client_secret&#125;'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当然，每个主题的修改方式是不一样的，主要是找到 <code>new Gitment</code> 的位置进行修改。</p></blockquote><h1 id="多设备同步"><a href="#多设备同步" class="headerlink" title="多设备同步"></a>多设备同步</h1><p>平时我会在实验室和宿舍两个地方写博客，但是博客的源码却只在一处，如何保证两处代码都最新呢？</p><p>这可以用两个思路进行解决：</p><ol><li>文件同步，即通过 OneDrive、DropBox 等文件同步工具进行同步。</li><li>代码同步，即使用 GitHub 等代码托管平台进行同步。</li></ol><p>其中文件同步会同步大量 node_modules 内的依赖模块代码（可以通过 <code>npm install</code> 重新安装），所以我选用了第二种代码同步的方法进行同步，毕竟也算是源代码么。<br>具体的流程可以参考：<a href="http://www.mashangxue123.com/Hexo/3611120980.html" target="_blank" rel="noopener">Hexo 多台电脑同步 源码保存 | 马上学123</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>呼呼呼，这篇文章从 5 月 10 日创建，一直到今天（5 月 27 日）才算基本完成（而且越后面越短），看来我的博客之路充满了坎坷啊…</p><p>不过如果有帮助到谁的话，哪怕只有一点点，也是非常开心了~</p><p>希望我还能产出下一篇博文，不要写完这篇就荒废了（立下 Flag</p><h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><p>2018/05/27 完成第一版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;眼看着半只脚要踏入前端工程师的坑了，正好去年申请的域名过期了，纠结了一阵还是申请了一个新域名（我的这个手啊，怎么就不听使唤呢&lt;/p&gt;
&lt;p&gt;域名能干嘛？最最最基础的就是搭个博客了，但又不想再花钱搞个服务器，想到之前在同学博客（强势推广一波→&lt;strong&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.bbag.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="博客 域名 HTTPS Hexo" scheme="https://blog.bbag.me/tags/%E5%8D%9A%E5%AE%A2-%E5%9F%9F%E5%90%8D-HTTPS-Hexo/"/>
    
  </entry>
  
</feed>
